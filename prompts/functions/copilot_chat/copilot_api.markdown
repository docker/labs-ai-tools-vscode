

```js
getEditorVersionHeaders(){
  return {
    "Editor-Version":this.getEditorInfo().format(),
    "Editor-Plugin-Version":this.getEditorPluginInfo().format()
  }
}}
getEditorInfo(){return new bE("vscode",kI.version)}
getEditorPluginInfo(){return new bE("copilot-chat",Sa.version)}
```

```js

```

```js
async _doRefreshRemoteAgents(){
  let e=this.logService.getLogger("RemoteAgents"),
      r=this.configurationService.getConfig(Ee.AgentsEndpointUrl),
      n=new Set(iA.keys());
  try {
    let o=this.authenticationService.anyGitHubSession?.accessToken;
    if(!o){
     e.warn("Unable to fetch remote agents because user is not signed in.");
     return
    }
    (await this.authenticationService.getCopilotToken()).sku?.startsWith("copilot_enterprise")&&this.registerAgent(e,null,r);
    let c=await(await this.fetcherService.fetch(`${r}/agents`,
                                                {method:"GET",
                                                 headers:{Authorization:JM.format("Bearer %s",o),
                                                          ...this.envService.getEditorVersionHeaders()}})).text(),
        u;
    try {
      if(u=JSON.parse(c).agents,!Array.isArray(u))
        throw new Error("Expected 'agents' to be an array")} 
    catch(l) {
      c.includes("access denied")||e.warn(`Invalid remote agent response: ${c} (${l})`);
      return
    }
    for(let l of u) n.delete(l.slug)||iA.set(l.slug,this.registerAgent(e,l,r))
  }
  catch(o) {
    e.warn(`Failed to load remote slash commands: ${o}`)
  }
  for(let o of n)
    iA.get(o).dispose(),iA.delete(o)
}
registerAgent(e,r,n){
  let o=new Ot,
      s=`github.copilot-dynamic.${r?.slug??"platform"}`,
      a=r?.slug??nZ,
      c=r?.description??"Get answers grounded in web search, code search, and your enterprise's knowledge bases",
      u={name:a,description:c,publisherName:r?.owner_login??"GitHub",fullName:r?.name??"GitHub"},
      l=o.add(ft.chat.createDynamicChatParticipant(s,u,async(d,p,f,m)=>{let h=Att(p),g=Tn(),
      v={sessionId:h,responseId:g,agentId:s,command:d.command};
  try{
    let y=new CI(r?`${n}/agents/${r.slug}?chat`:`${n}/agents/chat`,
                 {capabilities:{type:"chat",family:"remote"},id:"gpt-3.5-turbo",name:"Remote Agents",version:"1.0"},
                 4096),
        b=await this.promptVariablesService.resolveVariablesInPrompt(d.prompt,d.references),
        _=[],
        {copilot_skills:S,copilot_references:T}=await this.resolveCopilotSkills(a,d);
    T&&_.push(...T);
    let E=!1;
    try {
      let L=await this.prepareClientPlatformReferences([...d.references]);
      E=L.hasIgnoredFiles,L.clientReferences&&_.push(...L.clientReferences);
      for(let I of L.vscodeReferences)
        f.reference(I)
    }
    catch(L){
      return L instanceof Error&&L.message.includes("File seems to be binary and cannot be opened as text")?(f.markdown(ft.l10n.t("Sorry, binary files are not currently supported.")),{metadata:v}):{errorDetails:{message:L.message},metadata:v}
    }
    let O=new Map,
        F=wtt(d),
        j,
        M,
        ne=!1,
        Z=await this.chatMLFetcher.fetchMany([...Rtt(s,p),{role:"user",content:d.acceptedConfirmationData?.length||d.rejectedConfirmationData?.length?"":b.message,..._.length?{copilot_references:_}:void 0,copilot_confirmations:F?.length?F:void 0}],async(L,I,P)=>{if(P.copilotReferences){let U=(K,fe)=>{let te="url"in K?K.url:"url"in K.data?K.data.url:void 0;if(te&&typeof te=="string"&&!O.has(te)){let Y;if(CIe(K)){let je=zn.joinPath(this.vscodeExtensionContext.extensionUri,"assets","bing.svg");Y={light:je,dark:je}}else new URL(te).hostname==="github.com"&&(Y=new ft.ThemeIcon("github"));j?j?.report(new ft.ChatResponseReferencePart(zn.parse(te),Y)):f.reference(zn.parse(te),Y),O.set(te,fe??K)}};for(let K of P.copilotReferences)Array.isArray(K.data.results)?K.data.results.forEach(fe=>{U(fe,K)}):"url"in K.data&&typeof K.data.url=="string"&&U(K)}let q=(U,K)=>{M?.deferred.complete(M.resolvedMessage),j=U;let fe=new Cp;return M={deferred:fe,resolvedMessage:K},fe.p};if(P.copilotFunctionCalls)for(let U of P.copilotFunctionCalls)switch(U.name){case"bing-search":{try{let K=JSON.parse(U.arguments);f.progress(ft.l10n.t('Searching Bing for "{0}"...',K.query),async fe=>q(fe,ft.l10n.t('Bing search results for "{0}"',K.query)))}catch{}break}case"kb-search":{try{let K=JSON.parse(U.arguments);f.progress(ft.l10n.t('Searching knowledge base for "{0}"...',K.query),async fe=>q(fe,ft.l10n.t('Knowledge base results for "{0}"',K.query)))}catch{}break}case"codesearch":{try{let K=JSON.parse(U.arguments);f.progress(ft.l10n.t('Searching {0} for "{1}"...',K.scopingQuery,K.query),async fe=>q(fe,ft.l10n.t('Code search results for "{0}" in {1}',K.query,K.scopingQuery)))}catch{}break}}if(P.copilotErrors&&typeof f.warning=="function"){ne=!0;for(let U of P.copilotErrors)j?j?.report(new ft.ChatResponseWarningPart(U.message)):f.warning(U.message)}if(P.copilotConfirmation){ne=!0;let U=P.copilotConfirmation;f.confirmation(U.title,U.message,U.confirmation)}if(P.text){M?.deferred.complete(M.resolvedMessage);let U=new ft.MarkdownString(P.text);U.supportHtml=!0,f.markdown(U)}},m,2,y,void 0,{secretKey:this.authenticationService.anyGitHubSession?.accessToken,copilot_thread_id:h,...S?{copilot_skills:S}:void 0},{messageSource:`serverAgent.${r?r.slug:"platform"}`});if(v.copilot_references=[...new Set(O.values()).values()],Z.type==="success"&&E&&f.markdown(ft.l10n.t(cP)),Z.type!=="success"){if(e.warn(`Bad response from /agents/${a}: ${Z.type} ${Z.reason}`),Z.reason.includes("400 no docs found"))return{errorDetails:{message:"No docs found"},metadata:v};if(Z.type==="agent_unauthorized"){f.markdown(ft.l10n.t("Please authorize usage of this agent and resend your question."));let L=zn.parse(Z.authorizationUrl),I=new URL(Z.authorizationUrl);f.button({command:"vscode.open",title:ft.l10n.t("Authorize on {0}",I.hostname),arguments:[L]})}else{if(Z.type==="agent_failed_dependency")return{errorDetails:{message:ft.l10n.t("Sorry, an error occurred: {0}",Z.reason)},metadata:v};if(Z.type!=="unknown"||!ne)return{errorDetails:{message:Z.reason},metadata:v}}}return{metadata:v}}catch(y){return e.warn(`/agents/${a} failed: ${y}`),{metadata:v}}}));return l.iconPath=r?zn.parse(r.avatar_url):new ft.ThemeIcon("github"),a===nZ&&(l.participantVariableProvider={triggerCharacters:["#"],provider:{provideCompletionItems:async(d,p)=>(await this.getPlatformAgentSkills()).map(m=>{let h=new ft.ChatCompletionItem(`copilot.${m.name}`,"#"+m.name,[{value:m.insertText,level:ft.ChatVariableLevel.Full,description:m.description}]);return h.command=m.command,h.detail=m.description,h.fullName=m.fullName,h.icon=m.icon,h})}}),o.add(l.onDidReceiveFeedback(d=>Z6(this.telemetryService,d,s))),o}async prepareClientPlatformReferences(e){let r=[],n=[],o=!1;for(let a of e)if(a.value instanceof zn){if(await this.ignoreService.isCopilotIgnored(a.value)){o=!0;continue}let c=await this.workspaceService.openTextDocument(a.value);r.push({type:"client.file",data:{language:c.languageId,content:c.getText()},id:oZ.basename(a.value.path)}),n.push({variableName:a.name,value:a.value})}else if(a.name==="selection"){let{activeTextEditor:c}=this.tabsAndEditorsService;if(!c)throw new Error(ft.l10n.t({message:"Please open a text editor to use the `#selection` variable.",comment:"{Locked='`#selection`'}"}));if(await this.ignoreService.isCopilotIgnored(c.document.uri)){o=!0;continue}let u=c.selection.start.line,l=c.selection.isEmpty?new ft.Range(new ft.Position(u,0),new ft.Position(u+1,0)):c.selection;r.push({type:"client.selection",data:{start:{line:l.start.line,col:l.start.character},end:{line:l.end.line,col:l.end.character},content:c.document.getText(l)},id:oZ.basename(c.document.uri.path)}),n.push({variableName:a.name,value:new ft.Location(c.document.uri,l)})}this.gitService.isInitialized||await this.gitService.initialize();let s=this.gitService.repositories;for(let a of s){let c=h_(a);if(!c)continue;let[u,l]=c?.split("/");r.push({type:"github.repository",id:c,data:{type:"repository",name:l,ownerLogin:u,id:(await this.githubRepositoryService.getRepositoryInfo(u,l)).id}})}return{clientReferences:r,vscodeReferences:n,hasIgnoredFiles:o}}async listEnabledSkills(e,r){if(!this.enabledSkillsPromise){let n=`${e}/skills`,o=await this.fetcherService.fetch(n,{method:"GET",headers:{Authorization:JM.format("Bearer %s",r),...this.envService.getEditorVersionHeaders()}});this.enabledSkillsPromise=o.json().then(s=>s?.skills.reduce((a,c)=>a.add(c.slug),new Set))}return this.enabledSkillsPromise}async resolveCopilotSkills(e,r){if(e===nZ){let n=new Set,o=new Set;for(let s of r.references)if(vRe[s.name])n.add(vRe[s.name]);else if(s.name.startsWith(iZ)){n.add("kb-search"),await this.getKnowledgeBases();let a=this.knowledgeBases?.get(s.name.slice(iZ.length));a&&o.add(a)}return{copilot_skills:[...n],copilot_references:[...o]}}return{copilot_skills:[]}}async getKnowledgeBases(){if(this.knowledgeBases?.size)return{knowledgeBases:[...this.knowledgeBases.values()],organizationsMissingSSO:this.organizationsMissingSSO};let e=this.authenticationService.permissiveGitHubSession?.accessToken;if(!e)return{knowledgeBases:[],organizationsMissingSSO:!0};let r=await this.listKnowledgeBases(e),n=await r.text();r.headers.get("X-GitHub-SSO")&&r.headers.get("X-GitHub-SSO")?.split("partial-results; organizations=")[1]&&(this.organizationsMissingSSO=!0);try{let o=JSON.parse(n);this.knowledgeBases=new Map;let s=o.map(a=>({label:a.name,organization:a.owner.login,iconPath:new ft.ThemeIcon("github"),insertText:a.name,name:a.name,description:a.description,type:"github.knowledge-base",id:(0,bRe.randomUUID)(),data:{type:"knowledge-base",id:a.id}}));for(let a of s)this.knowledgeBases.set(a.name,a);return{knowledgeBases:[...this.knowledgeBases.values()],organizationsMissingSSO:this.organizationsMissingSSO}}catch(o){return console.error(o),{knowledgeBases:[],organizationsMissingSSO:this.organizationsMissingSSO}}}async listKnowledgeBases(e){return this.fetcherService.fetch("https://api.github.com/user/knowledge-bases",{method:"GET",headers:{Authorization:JM.format("Bearer %s",e),...this.envService.getEditorVersionHeaders()}})}async getKnowledgeBaseAutocompleteQuickPickItems(){let{knowledgeBases:e,organizationsMissingSSO:r}=await this.getKnowledgeBases(),n=[];if(r){let s=ft.l10n.t("Single-sign on to see knowledge bases from additional organizations");n.push(new ZM(s)),n.push({kind:ft.QuickPickItemKind.Separator,label:""})}let o=new Map;for(let s of e){let a=s.organization;o.has(a)||o.set(a,[]),o.get(a)?.push(s)}for(let s of[...o.keys()].sort()){let a=o.get(s);a?.length&&(n.push({kind:ft.QuickPickItemKind.Separator,label:s}),n.push(...a.sort((c,u)=>c.label.localeCompare(u.label))))}return n}async getPlatformAgentSkills(){let e=this.configurationService.getConfig(Ee.AgentsEndpointUrl),r=this.authenticationService.anyGitHubSession?.accessToken;if(!r)return[];let n=await this.listEnabledSkills(e,r);return[{name:"web",insertText:"#web",description:"Search Bing for real-time context",kind:"bing-search",command:void 0},{name:"kb",insertText:`#${iZ}`,icon:new ft.ThemeIcon("book"),fullName:"Knowledge Bases",description:"Search your enterprises' knowledge bases",kind:"kb-search",command:{title:"",command:yRe}}].filter(o=>n.has(o.kind))}};wI=V([R(0,le),R(1,ke),R(2,kr),R(3,Tt),R(4,GM),R(5,Xe),R(6,St),R(7,De),R(8,ko),R(9,Nc),R(10,Jt),R(11,he),R(12,zr),R(13,Po)],wI);function wtt(t){return[...t.acceptedConfirmationData?.map(r=>({state:"accepted",confirmation:r}))??[],...t.rejectedConfirmationData?.map(r=>({state:"dismissed",confirmation:r}))??[]]}function Rtt(t,e){let r=[];for(let n of e.history)if(n.participant===t&&(n instanceof ft.ChatRequestTurn&&r.push({role:"user",content:n.prompt}),n instanceof ft.ChatResponseTurn)){let o=n.result.metadata?.copilot_references,s=n.response.map(a=>a instanceof ft.ChatResponseMarkdownPart?a.value.value:"content"in a?a.content:null).filter(a=>!!a).join("");r.push({role:"assistant",content:s,...o?{copilot_references:o}:void 0})}return r}function Att(t){let e;for(let r of t.history)if(r instanceof ft.ChatResponseTurn){let n=r.result.metadata?.sessionId;if(typeof n=="string"){e=n;break}}return e??Tn()}var ktt=[...dRe,QJ,tZ,rZ,cRe(wI)],_Re=ktt;var xRe=Q(require("path"));var Co=class t{static fromRange(e){return new t(e.startLineNumber,e.endLineNumber)}static fromRangeInclusive(e){return new t(e.startLineNumber,e.endLineNumber+1)}static subtract(e,r){return r?e.startLineNumber<r.startLineNumber&&r.endLineNumberExclusive<e.endLineNumberExclusive?[new t(e.startLineNumber,r.startLineNumber),new t(r.endLineNumberExclusive,e.endLineNumberExclusive)]:r.startLineNumber<=e.startLineNumber&&e.endLineNumberExclusive<=r.endLineNumberExclusive?[]:r.endLineNumberExclusive<e.endLineNumberExclusive?[new t(Math.max(r.endLineNumberExclusive,e.startLineNumber),e.endLineNumberExclusive)]:[new t(e.startLineNumber,Math.min(r.startLineNumber,e.endLineNumberExclusive))]:[e]}static joinMany(e){if(e.length===0)return[];let r=new eF(e[0].slice());for(let n=1;n<e.length;n++)r=r.getUnion(new eF(e[n].slice()));return r.ranges}static join(e){if(e.length===0)throw new Fr("lineRanges cannot be empty");let r=e[0].startLineNumber,n=e[0].endLineNumberExclusive;for(let o=1;o<e.length;o++)r=Math.min(r,e[o].startLineNumber),n=Math.max(n,e[o].endLineNumberExclusive);return new t(r,n)}static ofLength(e,r){return new t(e,e+r)}static deserialize(e){return new t(e[0],e[1])}constructor(e,r){if(e>r)throw new Fr(`startLineNumber ${e} cannot be after endLineNumberExclusive ${r}`);this.startLineNumber=e,this.endLineNumberExclusive=r}contains(e){return this.startLineNumber<=e&&e<this.endLineNumberExclusive}get isEmpty(){return this.startLineNumber===this.endLineNumberExclusive}delta(e){return new t(this.startLineNumber+e,this.endLineNumberExclusive+e)}deltaLength(e){return new t(this.startLineNumber,this.endLineNumberExclusive+e)}get length(){return this.endLineNumberExclusive-this.startLineNumber}join(e){return new t(Math.min(this.startLineNumber,e.startLineNumber),Math.max(this.endLineNumberExclusive,e.endLineNumberExclusive))}toString(){return`[${this.startLineNumber},${this.endLineNumberExclusive})`}intersect(e){let r=Math.max(this.startLineNumber,e.startLineNumber),n=Math.min(this.endLineNumberExclusive,e.endLineNumberExclusive);if(r<=n)return new t(r,n)}intersectsStrict(e){return this.startLineNumber<e.endLineNumberExclusive&&e.startLineNumber<this.endLineNumberExclusive}overlapOrTouch(e){return this.startLineNumber<=e.endLineNumberExclusive&&e.startLineNumber<=this.endLineNumberExclusive}equals(e){return this.startLineNumber===e.startLineNumber&&this.endLineNumberExclusive===e.endLineNumberExclusive}toInclusiveRange(){return this.isEmpty?null:new ht(this.startLineNumber,1,this.endLineNumberExclusive-1,Number.MAX_SAFE_INTEGER)}toExclusiveRange(){return new ht(this.startLineNumber,1,this.endLineNumberExclusive,1)}mapToLineArray(e){let r=[];for(let n=this.startLineNumber;n<this.endLineNumberExclusive;n++)r.push(e(n));return r}forEach(e){for(let r=this.startLineNumber;r<this.endLineNumberExclusive;r++)e(r)}serialize(){return[this.startLineNumber,this.endLineNumberExclusive]}includes(e){return this.startLineNumber<=e&&e<this.endLineNumberExclusive}toOffsetRange(){return new ar(this.startLineNumber-1,this.endLineNumberExclusive-1)}},eF=class t{constructor(e=[]){this._normalizedRanges=e}get ranges(){return this._normalizedRanges}addRange(e){if(e.length===0)return;let r=OA(this._normalizedRanges,o=>o.endLineNumberExclusive>=e.startLineNumber),n=hm(this._normalizedRanges,o=>o.startLineNumber<=e.endLineNumberExclusive)+1;if(r===n)this._normalizedRanges.splice(r,0,e);else if(r===n-1){let o=this._normalizedRanges[r];this._normalizedRanges[r]=o.join(e)}else{let o=this._normalizedRanges[r].join(this._normalizedRanges[n-1]).join(e);this._normalizedRanges.splice(r,n-r,o)}}contains(e){let r=R9(this._normalizedRanges,n=>n.startLineNumber<=e);return!!r&&r.endLineNumberExclusive>e}intersects(e){let r=R9(this._normalizedRanges,n=>n.startLineNumber<e.endLineNumberExclusive);return!!r&&r.endLineNumberExclusive>e.startLineNumber}getUnion(e){if(this._normalizedRanges.length===0)return e;if(e._normalizedRanges.length===0)return this;let r=[],n=0,o=0,s=null;for(;n<this._normalizedRanges.length||o<e._normalizedRanges.length;){let a=null;if(n<this._normalizedRanges.length&&o<e._normalizedRanges.length){let c=this._normalizedRanges[n],u=e._normalizedRanges[o];c.startLineNumber<u.startLineNumber?(a=c,n++):(a=u,o++)}else n<this._normalizedRanges.length?(a=this._normalizedRanges[n],n++):(a=e._normalizedRanges[o],o++);s===null?s=a:s.endLineNumberExclusive>=a.startLineNumber?s=new Co(s.startLineNumber,Math.max(s.endLineNumberExclusive,a.endLineNumberExclusive)):(r.push(s),s=a)}return s!==null&&r.push(s),new t(r)}subtractFrom(e){let r=OA(this._normalizedRanges,a=>a.endLineNumberExclusive>=e.startLineNumber),n=hm(this._normalizedRanges,a=>a.startLineNumber<=e.endLineNumberExclusive)+1;if(r===n)return new t([e]);let o=[],s=e.startLineNumber;for(let a=r;a<n;a++){let c=this._normalizedRanges[a];c.startLineNumber>s&&o.push(new Co(s,c.startLineNumber)),s=c.endLineNumberExclusive}return s<e.endLineNumberExclusive&&o.push(new Co(s,e.endLineNumberExclusive)),new t(o)}toString(){return this._normalizedRanges.map(e=>e.toString()).join(", ")}getIntersection(e){let r=[],n=0,o=0;for(;n<this._normalizedRanges.length&&o<e._normalizedRanges.length;){let s=this._normalizedRanges[n],a=e._normalizedRanges[o],c=s.intersect(a);c&&!c.isEmpty&&r.push(c),s.endLineNumberExclusive<a.endLineNumberExclusive?n++:o++}return new t(r)}getWithDelta(e){return new t(this._normalizedRanges.map(r=>r.delta(e)))}};var tF=class t{constructor(e,r){this.lineRangeMapping=e,this.changes=r}flip(){return new t(this.lineRangeMapping.flip(),this.changes.map(e=>e.flip()))}};var rF=class t{constructor(e,r){this.lineCount=e;this.columnCount=r}static{this.zero=new t(0,0)}static lengthDiffNonNegative(e,r){return r.isLessThan(e)?t.zero:e.lineCount===r.lineCount?new t(0,r.columnCount-e.columnCount):new t(r.lineCount-e.lineCount,r.columnCount)}static betweenPositions(e,r){return e.lineNumber===r.lineNumber?new t(0,r.column-e.column):new t(r.lineNumber-e.lineNumber,r.column-1)}static ofRange(e){return t.betweenPositions(e.getStartPosition(),e.getEndPosition())}static ofText(e){let r=0,n=0;for(let o of e)o===`

```
